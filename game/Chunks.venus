local levelLoader = require('game.LevelLoader')
local chunkNames = require('data.chunks')
local shuffle = require('lib.shuffle')

return fn() {
  local chunks = {}

  fn chunks:init() {
    self.chunks = {}
    self.images = {}
    self.chunkData = {}
    self.cQueue = table_clone(chunkNames)
    shuffle(self.cQueue)

    ##Load images
    foreach chName in chunkNames {
      local tchunk = levelLoader()
      local data = tchunk:get(chName)
      self.chunkData[chName] = data
      tchunk:use(data)
      tchunk:loadImages(tchunk.loaded, 'rece/', self.images)
      tchunk.inArrow  = tchunk:remove('tiles/back-arrow.png')[1]
      tchunk.outArrow = tchunk:remove('tiles/next-arrow.png')[1]
      self.chunkData[chName].inArrow = tchunk.inArrow
      self.chunkData[chName].outArrow = tchunk.outArrow
    }

    ##Create starting chunks
    self:new()
    self:new()
    self:new()
  }

  fn chunks:getCurrent() {
    return self.chunks[2]
  }

  fn chunks:new(i) {
    local chunk = levelLoader()
    i = i or #self.chunks+1

    local n = self:rnd()
    local cd = table_clone(self.chunkData[n])
    chunk:use(cd, n)
    chunk.images = self.images
    chunk:setTileSize(16)
    chunk:setSolidLayers({'Main'})
    chunk.inArrow  = cd.inArrow
    chunk.outArrow = cd.outArrow
    chunk.width    = (chunk.outArrow.x - chunk.inArrow.x)
    chunk.height   = (chunk.outArrow.y - chunk.inArrow.y)
    chunk.xOffset  = 0
    chunk.yOffset  = 0
    if #self.chunks > 0 {
      local previous = self.chunks[#self.chunks]
      chunk.xOffset = previous.xOffset + previous.width
      chunk.yOffset = previous.yOffset + previous.height
      if i == 1 {
        previous = self.chunks[1]
        chunk.xOffset = previous.xOffset - chunk.width
        chunk.yOffset = previous.yOffset - chunk.height
      }
      foreach layer in chunk.loaded.layers {
        foreach entity in layer {
          if entity.type == 'Tile' {
            entity.x += chunk.xOffset
            entity.y += chunk.yOffset
          } else {
            entity.x += chunk.xOffset * chunk.tileSize
            entity.y += chunk.yOffset * chunk.tileSize
          }
        }
      }
    }

    table.insert(self.chunks, i, chunk)
  }

  fn chunks:draw() {
    local cx, cy = Camera.x - love.graphics.getWidth()/2, Camera.y-love.graphics.getHeight()/2
    local cw, ch = love.graphics.getWidth(), love.graphics.getHeight()
    foreach i, chunk in self.chunks {
      if DoShowChunkBorders {
        love.graphics.setLineWidth(5)
        love.graphics.line(chunk.xOffset * chunk.tileSize, cy, chunk.xOffset * chunk.tileSize, cy+love.graphics:getHeight())
        love.graphics.setLineWidth(1)
        love.graphics.print(chunk.loaded.name, chunk.xOffset * chunk.tileSize + 5, Player.pos:getY() - 20)
      }
      local x, y, w, h = chunk.xOffset * chunk.tileSize, cy-1, chunk.width * chunk.tileSize, ch*2
      if rect_overlap(x, y, w, h, cx, cy, cw, ch) {
        chunk:draw()
      }
    }
  }

  fn chunks:update(x, y) {
    if not x {x = Player.pos:getX()}
    if not y {y = Player.pos:getY()}
    local pChunk = Player.chunk
    if x > (pChunk.xOffset + pChunk.width) * pChunk.tileSize {
      table.remove(self.chunks, 1)
      self:new()
      Player.chunk = self:getCurrent()
    }
    if x < pChunk.xOffset * pChunk.tileSize {
      table.remove(self.chunks, #self.chunks)
      self:new(1)
      Player.chunk = self:getCurrent()
    }
  }

  fn chunks:rnd() {
    local i = love.math.random(3)
    local c = table.remove(self.cQueue, i)
    table.insert(self.cQueue, c)

    return c
    ##return chunkNames[love.math.random(1, #chunkNames)]
  }

  return chunks
}
