local levelLoader = require('game.LevelLoader')
local chunkNames = require('data.chunks')
local shuffle = require('lib.shuffle')

return fn() {
  local chunks = {}

  fn chunks:init() {
    self.playerChunkNum = 1
    self.chunks = {}
    self.images = {}
    self.chunkData = {}
    self.cQueue = table_clone(chunkNames)
    shuffle(self.cQueue)

    ##Load levels
    foreach chName in chunkNames {
      self.chunkData[chName] = self:load(chName)
    }

    ##Load start level
    self.chunkData['start'] = self:load(chunkNames.start)
    self.chunkData['empty'] = self:load(chunkNames.empty)

    ##Create starting chunks
    self:new('r')
    self:new('r')
    self:new('r')
  }

  fn chunks:load(fileName) {
    local out = {}

    local tchunk = levelLoader()
    local data = tchunk:get(fileName)
    out = data
    tchunk:use(data)
    tchunk:loadImages(tchunk.loaded, 'rece/', self.images)
    tchunk.inArrow  = tchunk:remove('tiles/back-arrow.png')[1]
    tchunk.outArrow = tchunk:remove('tiles/next-arrow.png')[1]
    out.inArrow = tchunk.inArrow
    out.outArrow = tchunk.outArrow

    return out
  }

  fn chunks:getCurrent() {
    return self.chunks[2]
  }

  fn chunks:new(dir) {
    local chunk = levelLoader()
    local i = dir == 'l' and 1 or #self.chunks + 1
    local n = self:rnd(dir)

    local cd = table_clone(self.chunkData[n])
    chunk:use(cd, n)
    chunk.images = self.images
    chunk:setTileSize(16)
    chunk:setSolidLayers({'Main'})
    chunk.inArrow  = cd.inArrow
    chunk.outArrow = cd.outArrow
    chunk.width    = (chunk.outArrow.x - chunk.inArrow.x)
    chunk.height   = (chunk.outArrow.y - chunk.inArrow.y)
    chunk.xOffset  = 0
    chunk.yOffset  = 0
    if #self.chunks > 0 {
      local previous = self.chunks[#self.chunks]
      chunk.xOffset = previous.xOffset + previous.width
      chunk.yOffset = previous.yOffset + previous.height
      if i == 1 {
        previous = self.chunks[1]
        chunk.xOffset = previous.xOffset - chunk.width
        chunk.yOffset = previous.yOffset - chunk.height
      }
      foreach layer in chunk.loaded.layers {
        foreach entity in layer {
          if entity.type == 'Tile' {
            entity.x += chunk.xOffset
            entity.y += chunk.yOffset
          } else {
            entity.x += chunk.xOffset * chunk.tileSize
            entity.y += chunk.yOffset * chunk.tileSize
          }
        }
      }
    }

    table.insert(self.chunks, i, chunk)
  }

  fn chunks:draw() {
    local cx, cy = Camera.x - love.graphics.getWidth()/2, Camera.y-love.graphics.getHeight()/2
    local cw, ch = love.graphics.getWidth(), love.graphics.getHeight()
    foreach i, chunk in self.chunks {
      if DoShowChunkBorders {
        love.graphics.setLineWidth(5)
        love.graphics.line(chunk.xOffset * chunk.tileSize, cy, chunk.xOffset * chunk.tileSize, cy+love.graphics:getHeight())
        love.graphics.setLineWidth(1)
        love.graphics.print(chunk.loaded.name, chunk.xOffset * chunk.tileSize + 5, Player.pos:getY() - 20)
      }
      local x, y, w, h = chunk.xOffset * chunk.tileSize, cy-1, chunk.width * chunk.tileSize, ch*2
      if rect_overlap(x, y, w, h, cx, cy, cw, ch) {
        chunk:draw()
      }
    }
  }

  fn chunks:update(x, y) {
    if not x {x = Player.pos:getX()}
    if not y {y = Player.pos:getY()}
    local pChunk = Player.chunk
    if x > (pChunk.xOffset + pChunk.width) * pChunk.tileSize {
      self.playerChunkNum++
      table.remove(self.chunks, 1)
      self:new('r')
      Player.chunk = self:getCurrent()
    }
    if x < pChunk.xOffset * pChunk.tileSize and self.playerChunkNum > 0 {
      self.playerChunkNum--
      table.remove(self.chunks, #self.chunks)
      self:new('l')
      Player.chunk = self:getCurrent()
    }
  }

  fn chunks:rnd(dir) {
    if (#self.chunks == 0) or (self.playerChunkNum == 1 and dir == 'l') {
      return 'start'
    }

    if dir == 'l' and self.playerChunkNum <= 0 {
      return 'empty'
    }


    ##Random
    local i = love.math.random(3)
    local c = table.remove(self.cQueue, i)
    table.insert(self.cQueue, c)

    return c
  }

  return chunks
}
